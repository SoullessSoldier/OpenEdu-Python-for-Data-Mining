# Сортировки, множества и словари
# 5.1 Сортировка
# Списки лучше упорядочивать
# Считаем список и упорядочим его функцией sort()
# Метод sort только для списков, и он изменяет состояние списка.
#
###
# print('Список - считываем с одной строки и упорядочиваем функцией sort()')
# lst=list(map(int,input().split()))
# lst.sort()
# print(*lst)
###
#
# Кроме функции sort() есть функция sorted()
# В отличие от sort() она делает копию
#
###
# print('Теперь через sorted()')
# sortedlst=sorted(lst)
# print(*sortedlst)
###
# Sorted() нужен 1) когда мы хотим исходный список без изменения,
# и 2)аргументом sorted вместо списка может стоять что угодно, из чего можно вынимать элементы
# например, строка
###
# print('Сделаем sorted от обычной строки bfdace:')
# sortedlst=sorted('bfdace')
# print(*sortedlst)
###
# Сортировка по убыванию
# Можно отсортировать список по возрастанию, а затем развернуть его
# Либо указать параметр reverse в функции sorted()
###
# print('Сортировка по убыванию')
# lst=list(map(int,input().split()))
# sortedlst=sorted(lst,reverse=True)
# print(*sortedlst)
###
# Сортировка кортежа кортежей
# Метод sort() применять нельзя, т.к. кортеж неизменяем
###
# print('Сортировка кортежа кортежей')
# tup=(('Ivanov',190),('Petrov',175),('Barabanov',180))
# sortedtup=sorted(tup)
# print(*sortedtup)
###
# В кортежах сначала сравниваются первые элементы
# Если надо отсортировать по вторым элементам
# Можно (но не очень красиво) поменять порядок элементов
# Но есть и специальный механизм
###
# print('Сортировка по второму элементу')
# def mykey(x):
#    return x[1]#возвращаем второй элемент принятого кортежа, первый - x[0]
# sortedtup=sorted(tup, key=mykey)
# print(*sortedtup)
###
# если будут элементы с одинаковым ключом
# В Питоне и sort, и sorted оставляют порядок следования элементов таким, какой он был
# Это свойство называется УСТОЙЧИВОСТЬЮ сортировки
###
# def mykey(x):
#    return x[1]
# print('Сортировка кортежа кортежей с совпадением сортируемых элементов')
# tup=(('Ivanov',190),('Petrov',175),('Barabanov',180),('abc',175))
# sortedtup=sorted(tup,key=mykey)
# print(*sortedtup)
###
#
# 5.1-1
# Отсортируйте данный массив, используя встроенную сортировку.
# Первая строка входных данных содержит количество элементов в списке N. Далее идет N целых #чисел, выведите эти числа в порядке неубывания (это как по возрастанию, термин #"неубывание" используется чтобы избежать неоднозначного понимания в случае наличия #одинаковых чисел в списке).
###
# print('5.1-1')
# n=int(input('Введите количество элементов: '))
# a=list(map(int,input(f'Введите {n} чисел через пробел: ').split()))
# print(*sorted(a))
###
#
# 5.1-2
# В первой строке задаётся количество названий столиц - число N. В следующих N строках задаются названия столиц по одному в строке. Отсортируйте названия столиц в алфавитном порядке и выведите их по одному в строке.
###
# print('5.1-2')
# n=int(input('Введите количество элементов: '))
# a=[]
# i=0
# for i in range(n):
#    a.append(input('Введите столицу: '))
# a.sort()
# for i in a:
#    print(i)
###
# 5.1-3
# В первой строке задаётся количество названий столиц и государств - число N. В следующих N #строках задаются названия столиц и государств по одному в строке, слова разделяются одним #пробелом. Отсортируйте названия столиц и государств по названию государства в алфавитном #порядке и выведите их по одному в строке.
###
# print('5.1-3')
# def mykey(x):
#    return x[1]
# n=int(input('Введите количество элементов: '))
# a=[]
# i=0
# for i in range(n):
#    a.append(input('Введите так: страна[пробел]столица: ').split())
# sortedlst=sorted(a,key=mykey)
# for i in sortedlst:
#    print(*i)
###
#
# 5.2 Множества и операции над их элементами
#
# Задача - проверка наличия слова в тексте, или элемента в множестве
# В множество можно положить любой неизменяемый объект (список - изменяемый объект)
###
# myset={2,3,5,7,11}
# Есть ли число в множестве?
# x=int(input())
# print(x in myset)#True or False
###
# Добавить элемент в множество
# myset.add(x)
# Удалить элемент из множества
# myset.remove(x)
# Если попробовать удалить несуществующий элемент, remove выпадет в ошибку.
# Есть еще один более безопасный метод discard для удаления элемента:
# В случае отсутствия элемента он не будет делать ничего (не выпадет в ошибку)
# myset.discard(x)
# как создать множество из введенных элементов
# myset=set(map(int,input('Введите числа через пробел: ').split()))
# В множестве нет повторов! Введенные повторы останутся только один раз!
# Элементы множества не сортированы
# Перебрать все элементы множества, возвести их в квадрат и напечатать:
###
# for x in myset:
#    print(x**x,end=' ')
# Сортировка через функцию sorted(), она создаст список, упорядоченный по возрастанию
# Сортировка в множстве разных типов не работает
#
# 5.2-1
# Дан список чисел. Определите, сколько в нем встречается различных чисел. Не забудьте, что функция len подходит и для множеств.
###
# myset=set(map(int,input('Введите список через пробел: ').split()))
# print(len(myset))
###
#
# 5.2-2
# Даны два списка чисел. Посчитайте, сколько чисел содержится одновременно как в первом списке, так и во втором.
###
# a=set(map(int,input('Введите список1 через пробел: ').split()))
# b=set(map(int,input('Введите список2 через пробел: ').split()))
# cnt=0
# for i in a:
#    cnt+=1 if i in b
# print(cnt)
###
#
# 5.2-3
# Во входной строке записана последовательность чисел через пробел. Для каждого числа
# выведите слово YES (в отдельной строке), если это число ранее встречалось в
# последовательности или NO, если не встречалось.
###
# numbers = list(map(int,input().split()))
# occur_before = set()
# for num in numbers:
#    if num in occur_before:
#        print('YES')
#    else:
#        print('NO')
#        occur_before.add(num)
###
#
# 5.3 Групповые операции над множествами
#
# Пусть есть два множества, нам нужно найти пересечение, т.е. элементы, которые есть и там,
# и там.
#
# set1=set(map(int,input('Введите первое множество: ').split()))
# set2=set(map(int,input('Введите второе множество: ').split()))
# Как найти пересечение? Для каждого элемента из 1го множества перебрать, есть ли он во 2ом
# множестве
# Если есть, то кладем его в третье множество
# В Питоне есть специальная операция - & - пересечение множеств
# print('Пересечение множеств:')
# set3=set1&set2
# print(*set3)
# В Питоне есть специальная операция - | - объединение множеств
# print('Объединение множеств:')
# set4=set1|set2
# print(*set4)
# В Питоне есть специальная операция - - - вычитание множеств - все элементы множества 1 без
# элементов из множества 2
# print('Вычитание множеств:')
# set5=set1-set2
# print(*set5)
# В Питоне есть специальная операция - ^ - исключающее или двух множеств
# Она же симметрическая разность
# print('Симметрическая разность множеств:')
# set6=set1^set2
# print(*set6)
# Операции над множествами происходят небыстро
# Там, где возможно, вместо объединения множеств лучше делать add()
# Создание пустого множества
# a=set()
#
# не надо делать a={}
# 5.3-1
###
# Даны два списка чисел. Выведите все числа, которые входят как в первый, так и во второй
# список в порядке возрастания.
###
# Вывести упорядоченное пересечение двух множеств
# a1=set(map(int,input().split('Введите первое множество: ')))
# a2=set(map(int,input().split('Введите второе множество: ')))
# print(*sorted(a1&a2))
###
#
# 5.3-2
# Каждый из N школьников некоторой школы знает Mi языков. Определите, какие языки знают все
# школьники и языки, которые знает хотя бы один из школьников.
# Первая строка входных данных содержит количество школьников N. Далее идет N чисел Mi,
# после каждого из чисел идет Mi строк, содержащих названия языков, которые знает i-й
# школьник.
# В первой строке выведите количество языков, которые знают все школьники. Начиная со второй
# строки - список таких языков, упорядоченный по алфавиту. Затем - количество языков,
# которые знает хотя бы один школьник, на следующих строках - список таких языков,
# упорядоченный по алфавиту.
# Sample Input:
# 3
# 3
# Russian
# English
# Japanese
# 2
# Russian
# English
# 1
# English
#
# Sample Output:
# 1
# English
# 3
# English
# Japanese
# Russian
###
# students = [{input() for j in range(int(input()))} for i in range(int(input()))]
# known_by_everyone, known_by_someone = set.intersection(*students), set.union(*students)
# print(len(known_by_everyone), *sorted(known_by_everyone), sep='\n')
# print(len(known_by_someone), *sorted(known_by_someone), sep='\n')
###
#
# 5.4 Словари
# Словарь - пары ключ:значение
# dct={}
# dct={'a':1,'b':2,'c':3}
# print(dct)
# В словаре, как и в множестве, все ключи уникальны. Элементы неупорядочены.
# Добавление в словарь
# dct['d']=4
# print(dct)
# Доступ к элементам по ключу
# dct['a']=4
# print(dct)
# Есть ли ключ в словаре
# print('x' in dct)
# Содержимое - неизменяемые объекты, все кроме списков, множеств, словарей.
# Удаление элемента из словаря
# del dct['a']
# print(dct)
# Перебрать все ключи и напечатать пары ключ:значение
# for key in dct:#for key in sorted(dct) - чтобы упорядочить ключи по алфавиту
#    print(key,dct[key])
# Словарь позволяет только по ключу получать значения, не наоборот
# Для реализации поиска ключа по значению нужно создать обратный словарь
# Записная книжка
# dct2={}
# for key in sorted(dct):
#    dct2[dct[key]]=key
# print(dct)
# print(dct2)
###
# 5.4-1
# Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему
# слову. Все слова в словаре различны. Для одного данного слова определите его синоним.
# Программа получает на вход количество пар синонимов N. Далее следует N строк, каждая
# строка содержит ровно два слова-синонима. После этого следует одно слово.
# Программа должна вывести синоним к данному слову.
# Sample Input:
# 3
# Hello Hi
# Bye Goodbye
# List Array
# Goodbye

# Sample Output:
# Bye
###
# n = int(input())
# d = {}
# for i in range(n):
#    first, second = input().split()
#    d[first] = second
#    d[second] = first
# print(d[input()])
# print(d)
###
# 5.4-2
# Дан список стран и городов каждой страны. Затем даны названия городов. Для каждого города
# укажите, в какой стране он находится.
#
# Программа получает на вход количество стран N. Далее идет N строк, каждая строка
# начинается с названия страны, затем идут названия городов этой страны. В следующей строке
# записано число M, далее идут M запросов — названия каких-то M городов, перечисленных выше.
#
# Для каждого из запроса выведите название страны, в котором находится данный город.
# Sample Input:
#
# 2
# Russia Moscow Petersburg Novgorod Kaluga
# Ukraine Kiev Odessa
# 3
# Odessa
# Moscow
# Novgorod
# Sample Output:
# Ukraine
# Russia
# Russia
###
# motherland = {}
# for i in range(int(input())):
#    country, *cities = input().split()
#    for city in cities:
#        motherland[city] = country

# for i in range(int(input())):
#    print(motherland[input()])
###
#
# 5.5 Пример решения сложной задачи
# На тему двух словарей
# Пример: Дан англо-латинский словарь, надо составить латино-английский словарь
# aaa='''3 записи:
# apple - malum, pomum, popula
# fruit - baca, bacca, popum
# punishment - malum, multa'''
#
#
# def parse(s):
#    #s=apple - malum, pomum, popula
#    #output - latin word and list of english words
#    english=s[:s.find(' - ')]
#   latinss=s[s.find(' - ')+3:]
#    latins=latinss.split(',')
#    for i in range(len(latins)):
#        latins[i]=latins[i].strip()
#    return (english,latins)

# сделаем словарь, ключ - латинское слово, значение - список английских слов
# latinenglish={}
# n=int(input())#считать количество записей
# for i in range(n):
#    s=input()
#    english,latins=parse(s)
#    for latin in latins:
#        if latin not in latinenglish:
#            latinenglish[latin]=[]
#        latinenglish[latin].append(english)
##Пошeл вывод
# print(len(latinenglish))
# for latin in sorted(latinenglish):
#    print(latin, end=' - ')
#    print(', '.join(sorted(latinenglish[latin])))
###
#
#
#
# 5.5-1
# На вход подается строка. Словом считается последовательность непробельных символов идущих
# подряд, слова разделены одним или большим числом пробелов или символами конца строки. Для
# каждого слова из этого текста подсчитайте, сколько раз оно встречалось в этом тексте ранее.
#
# Sample Input:
# one two one tho three
# Sample Output:
# 0 0 1 0 0
###
# counter = {}
# for word in input().split():
#    counter[word] = counter.get(word, 0) + 1
#    print(counter[word] - 1, end=' ')
###
# 5.5-2
# Дана строка. Выведите слово, которое в этой строке встречается чаще всего. Если таких слов
# несколько, выведите то, которое меньше в лексикографическом (алфавитном) порядке.
#
# Sample Input:
# apple orange banana banana orange
# Sample Output:
# banana
###
# counter = {}
# line = input().split()
# for word in line:
#    counter[word] = counter.get(word, 0) + 1
#
# max_count = max(counter.values())
# most_frequent = [k for k, v in counter.items() if v == max_count]
# print(min(most_frequent))
###
#
# Некоторый банк хочет внедрить систему управления счетами клиентов, поддерживающую следующие операции:

# Пополнение счета клиента. Снятие денег со счета. Запрос остатка средств на счете. Перевод
# денег между счетами клиентов. Начисление процентов всем клиентам.

# Вам необходимо реализовать такую систему. Клиенты банка идентифицируются именами
# (уникальная строка, не содержащая пробелов). Первоначально у банка нет ни одного клиента.
# Как только для клиента проводится операция пололнения, снятия или перевода денег, ему
# заводится счет с нулевым балансом. Все дальнейшие операции проводятся только с этим
# счетом. Сумма на счету может быть как положительной, так и отрицательной, при этом всегда
# является целым числом.

# Входной данные содержат количество и последовательность операций. Возможны следующие
# операции: DEPOSIT name sum - зачислить сумму sum на счет клиента name. Если у клиента нет #счета, то счет создается. WITHDRAW name sum - снять сумму sum со счета клиента name. Если
# у клиента нет счета, то счет создается. BALANCE name - узнать остаток средств на счету
# клиента name. TRANSFER name1 name2 sum - перевести сумму sum со счета клиента name1 на
# счет клиента name2. Если у какого-либо клиента нет счета, то ему создается счет. INCOME p
# - начислить всем клиентам, у которых открыты счета, pот суммы счета. Проценты начисляются
# только клиентам с положительным остатком на счету, если у клиента остаток отрицательный,
# то его счет не меняется. После начисления процентов сумма на счету остается целой, то есть
# начисляется только целое число денежных единиц. Дробная часть начисленных процентов
# отбрасывается.

# Для каждого запроса BALANCE программа должна вывести остаток на счету данного клиента. #Если же у клиента с запрашиваемым именем не открыт счет в банке, выведите ERROR.

# Sample Input:
#
# 7
# DEPOSIT Ivanov 100
# INCOME 5
# BALANCE Ivanov
# TRANSFER Ivanov Petrov 50
# WITHDRAW Petrov 100
# BALANCE Petrov
# BALANCE Sidorov

# Sample Output:

# 105
# -50
# ERROR
###
# def deposit(name, sum):
#    bank[name] = bank.get(name, 0) + int(sum)
#
#
# def withdraw(name, sum):
#    bank[name] = bank.get(name, 0) - int(sum)
#
#
# def balance(name):
#    if name not in bank:
#        print('ERROR')
#    else:
#        print(bank[name])
#
# def transfer(name_from,name_to,sum):
#    withdraw(name_from,sum)
#    deposit(name_to,sum)
#
# def unknown_operation():
#    print('UNKNOWN OPERATION')
#
# def income(percent):
#    for k, v in bank.items():
#        if v > 0:
#            bank[k] = int(v * ((int(percent)/100) + 1))
#

# bank = dict()
#
# for i in range(int(input())):
#    line = input().split()
#    if 'BALANCE' in line:
#        balance(line[1])
#    elif 'DEPOSIT' in line:
#        deposit(line[1], line[2])
#    elif 'WITHDRAW' in line:
#        withdraw(line[1], line[2])
#    elif 'INCOME' in line:
#        income(line[1])
#    elif 'TRANSFER' in line:
#        transfer(line[1],line[2],line[3])
#    else:
#        unknown_operation()
#